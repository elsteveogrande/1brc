/*
 *  Copyright 2023 The original authors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package dev.morling.onebrc;

import java.io.*;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;

import static dev.morling.onebrc.CalculateAverage_elsteveogrande.MAX_NAME_LENGTH;
import static dev.morling.onebrc.CalculateAverage_elsteveogrande.MAX_TEMP_LENGTH;

public class CalculateAverage_elsteveogrande {

    static final int MAX_NAME_LENGTH = 256;
    static final int MAX_TEMP_LENGTH = 8;
    static final String FILE = "./measurements.txt";
    static final int NPROCS = Runtime.getRuntime().availableProcessors();

    private void run() throws IOException {
        Task[] tasks = new Task[NPROCS];

        try (var file = new RandomAccessFile(new File(FILE), "r")) {
            long[] offsets = new long[NPROCS + 1];

            var size = file.length();
            for (int i = 1; i < NPROCS; i++) {
                long offset = (long) (size * ((float) i) / NPROCS);
                file.seek(offset);
                // noinspection StatementWithEmptyBody
                while (file.readByte() != '\n') {
                }
                offsets[i] = file.getFilePointer();
            }
            offsets[NPROCS] = size;

            for (int i = 0; i < NPROCS; i++) {
                tasks[i] = new Task(
                        file.getChannel().map(
                                FileChannel.MapMode.READ_ONLY,
                                offsets[i],
                                offsets[i + 1] - offsets[i]));
                tasks[i].start();
            }

            for (int i = 0; i < NPROCS; i++) {
                while (true) {
                    try {
                        tasks[i].join();
                        break;
                    }
                    catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }

        final SortedMap<String, Station> stationsByName = new TreeMap<>();
        for (var task : tasks) {
            task.stations.forEach((_, station) -> {
                var s = stationsByName.computeIfAbsent(station.name, Station::new);
                s.merge(station);
            });
        }

        System.out.println(stationsByName);
    }

    public static void main(String[] args) throws Exception {
        (new CalculateAverage_elsteveogrande()).run();
    }
}

final class Station {
    final String name;
    float min = Float.POSITIVE_INFINITY;
    float max = Float.NEGATIVE_INFINITY;
    double total = 0;
    int count = 0;

    Station(String name) {
        this.name = name;
    }

    void update(float val) {
        min = Math.min(min, val);
        max = Math.max(max, val);
        total += val;
        count++;
    }

    public void merge(Station that) {
        min = Math.min(this.min, that.min);
        max = Math.max(this.max, that.max);
        this.total += that.total;
        this.count += that.count;
    }

    public String toString() {
        if (this.count == 0) {
            return "[no records]";
        }
        return String.format("%.1f", this.min)
                + '/' + String.format("%.1f", this.total / this.count)
                + '/' + String.format("%.1f", this.max);
    }
}

/**
 * A thread which will process approx. {@code 1/N} of the input file
 * (where {@code N} is the number of threads).
 */
class Task extends Thread {
    /** Subset of the memory-mapped input file */
    final MappedByteBuffer mmap;

    /**
     * Task-private mapping of stations,
     * with keys generated by {@link Util#key(byte[], int)}.
     */
    final Map<Long, Station> stations = new HashMap<>();

    /**
     * @param mmap Subset of the memory-mapped input file
     */
    Task(MappedByteBuffer mmap) {
        this.mmap = mmap;
    }

    @Override
    public void run() {
        final int n = mmap.capacity();

        byte[] nameBytes = new byte[MAX_NAME_LENGTH];
        byte[] tempBytes = new byte[MAX_TEMP_LENGTH];

        /*
         * This task's main loop:
         * - start at the beginning offset of the (memory-mapped) file
         * - consume until we hit the end of our chunk (or EOF)
         */
        int i = 0;
        while (i < n) {
            byte b;

            // Each entry is expected to be in the format:
            // station name, semicolon, temperature, endline

            // Read the name's UTF-8 bytes, stop when we hit semicolon
            int nameSize = 0;
            while ((b = mmap.get(i++)) != ';') {
                nameBytes[nameSize++] = b;
            }

            // Read the temperature reading, stop when we hit the newline
            int tempSize = 0;
            while ((b = mmap.get(i++)) != '\n') {
                tempBytes[tempSize++] = b;
            }

            // Find (possibly create) this station.
            // (Avoid creating a String unless needed.)
            final var ns = nameSize;
            var station = stations.computeIfAbsent(
                    Util.key(nameBytes, nameSize),
                    _ -> new Station(new String(nameBytes, 0, ns)));

            // Parse temperature reading, and update station's stats
            var temp = Util.parseFloatDot1(tempBytes);
            station.update(temp);
        }
    }
}

final class Util {
    /**
     * Convert a string of bytes (but not a {@code String})
     * into a "key", which is an opaque {@literal long} value.
     * The rationale is, 64-bit integers as map keys (instead of {@link String}s)
     * will result in better performance.
     *
     * <p>
     * The returned key is a hash of the input bytes;
     * therefore it's not guaranteed to be collision-free, but
     * is "good enough" for our purposes.
     * </p>
     */
    static long key(byte[] bytes, int len) {
        int i = 0;
        long ret = 0L;
        byte b;
        while (i < len) {
            b = bytes[i++];
            ret = (59L * ret) + b;
        }
        return ret;
    }

    /**
     * Parse bytes represting a temperature reading into a float.
     * The input format is expected to be:
     * <pre><code>
     *     optionalMinus digit+ literalDot {digit}
     * </code></pre>
     * <p>
     * E.g. {@code -31.4} or {@code 15.9}
     * </p>
     */
    static float parseFloatDot1(byte[] s) {
        byte b;
        int i = 0;

        boolean neg = false;
        if (s[i] == '-') {
            // Skip the leading minus sign, record that this is negative
            ++i;
            neg = true;
        }

        // Read in base-10 digits, up to the expected '.' char
        float ret = 0.0f;
        while ((b = s[i++]) != '.') {
            ret = (ret * 10.0f) + (float) (b - '0');
        }

        // Read the final digit which is after the '.'
        ret += ((s[i] - '0') / 10.0f);

        return neg ? -ret : ret;
    }
}
