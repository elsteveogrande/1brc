/*
 *  Copyright 2023 The original authors
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package dev.morling.onebrc;

import java.io.*;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.*;
import java.util.function.Function;

import static dev.morling.onebrc.CalculateAverage_elsteveogrande.MAX_NAME_LENGTH;
import static dev.morling.onebrc.CalculateAverage_elsteveogrande.MAX_TEMP_LENGTH;

public class CalculateAverage_elsteveogrande {

    static final int MAX_NAME_LENGTH = 256;
    static final int MAX_TEMP_LENGTH = 8;
    static final String FILE = "./measurements.txt";
    static final int NPROCS = Runtime.getRuntime().availableProcessors();

    void initOffsets(long[] offsets, RandomAccessFile file) throws IOException {
        var size = file.length();
        for (int i = 1; i < NPROCS; i++) {
            long offset = (long) (size * ((float) i) / NPROCS);
            file.seek(offset);
            // noinspection StatementWithEmptyBody
            while (file.readByte() != '\n') {
            }
            offsets[i] = file.getFilePointer();
        }
        offsets[NPROCS] = size;
    }

    void run(RandomAccessFile file) throws IOException {
        // Overview: we'll use NPROCS (equal to number of CPU cores)
        // tasks to process the input file, each task handling roughly
        // 1/N of the data, and aggregate the results.

        // First compute the offset ranges for these tasks.
        // Task `t`, where `t` is in the range [0, NPROCS),
        // will start at `offsets[t]` and stop at `offsets[t + 1]`.
        // The last offset (at index NPROCS) is the size of the file.
        long[] offsets = new long[NPROCS + 1];
        initOffsets(offsets, file);

        // Build and start each task.
        Task[] tasks = new Task[NPROCS];
        for (int i = 0; i < NPROCS; i++) {
            tasks[i] = new Task(
                    file.getChannel().map(
                            FileChannel.MapMode.READ_ONLY,
                            offsets[i],
                            offsets[i + 1] - offsets[i]));
            tasks[i].start();
        }

        // Wait for all tasks to complete.
        for (int i = 0; i < NPROCS; i++) {
            while (true) {
                try {
                    tasks[i].join();
                    break;
                }
                catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }

        // Finally aggregate all the results and print out the aggregation.
        final SortedMap<String, Station> stationsByName = new TreeMap<>();
        for (var task : tasks) {
            task.stations.values().forEach(station -> {
                var s = stationsByName.computeIfAbsent(station.name, Station::new);
                s.merge(station);
            });
        }

        System.out.println(stationsByName);
    }

    public static void main(String[] args) throws Exception {
        try (var file = new RandomAccessFile(new File(FILE), "r")) {
            (new CalculateAverage_elsteveogrande()).run(file);
        }
    }
}

final class Station {
    final String name;
    float min = Float.POSITIVE_INFINITY;
    float max = Float.NEGATIVE_INFINITY;
    double total = 0;
    int count = 0;

    Station(String name) {
        this.name = name;
    }

    void update(float val) {
        min = Math.min(min, val);
        max = Math.max(max, val);
        total += val;
        count++;
    }

    public void merge(Station that) {
        min = Math.min(this.min, that.min);
        max = Math.max(this.max, that.max);
        this.total += that.total;
        this.count += that.count;
    }

    public String toString() {
        if (this.count == 0) {
            return "[no records]";
        }
        return String.format("%.1f", this.min)
                + '/' + String.format("%.1f", this.total / this.count)
                + '/' + String.format("%.1f", this.max);
    }
}

/**
 * A thread which will process approx. {@code 1/N} of the input file
 * (where {@code N} is the number of threads).
 */
class Task extends Thread {
    /** Subset of the memory-mapped input file */
    final MappedByteBuffer mmap;

    /**
     * Task-private mapping of stations,
     * with keys generated by {@link Util#key(byte[], int)}.
     */
    final Map<Integer, Station> stations = new ArrayMap<>();

    /**
     * @param mmap Subset of the memory-mapped input file
     */
    Task(MappedByteBuffer mmap) {
        this.mmap = mmap;
    }

    @Override
    public void run() {
        final int n = mmap.capacity();

        byte[] nameBytes = new byte[MAX_NAME_LENGTH];
        byte[] tempBytes = new byte[MAX_TEMP_LENGTH];

        /*
         * This task's main loop:
         * - start at the beginning offset of the (memory-mapped) file
         * - consume until we hit the end of our chunk (or EOF)
         */
        int i = 0;
        while (i < n) {
            byte b;

            // Each entry is expected to be in the format:
            // station name, semicolon, temperature, endline

            // Read the name's UTF-8 bytes, stop when we hit semicolon
            int nameSize = 0;
            while ((b = mmap.get(i++)) != ';') {
                nameBytes[nameSize++] = b;
            }

            // Read the temperature reading, stop when we hit the newline
            int tempSize = 0;
            while ((b = mmap.get(i++)) != '\n') {
                tempBytes[tempSize++] = b;
            }

            // Find (possibly create) this station.
            var station = getStation(nameBytes, nameSize);

            // Parse temperature reading, and update station's stats
            var temp = Util.parseFloatDot1(tempBytes);
            station.update(temp);
        }
    }

    Station getStation(byte[] nameBytes, int nameSize) {
        // (Avoid creating a String unless needed.)
        return stations.computeIfAbsent(
                Util.key(nameBytes, nameSize),
                _ -> new Station(new String(nameBytes, 0, nameSize)));
    }
}

final class Util {
    /**
     * Convert a string of bytes (but not a {@code String})
     * into a "key", which is an opaque {@literal long} value.
     * The rationale is, 64-bit integers as map keys (instead of {@link String}s)
     * will result in better performance.
     *
     * <p>
     * The returned key is a hash of the input bytes;
     * therefore it's not guaranteed to be collision-free, but
     * is "good enough" for our purposes.
     * </p>
     */
    static int key(byte[] bytes, int len) {
        int i = 0;
        int ret = 0;
        byte b;
        while (i < len) {
            b = bytes[i++];
            ret = (59 * ret) + b;
        }
        return (int) (ret & 0xffffL);
    }

    /**
     * Parse bytes represting a temperature reading into a float.
     * The input format is expected to be:
     * <pre><code>
     *     optionalMinus digit+ literalDot {digit}
     * </code></pre>
     * <p>
     * E.g. {@code -31.4} or {@code 15.9}
     * </p>
     */
    static float parseFloatDot1(byte[] s) {
        byte b;
        int i = 0;

        boolean neg = false;
        if (s[i] == '-') {
            // Skip the leading minus sign, record that this is negative
            ++i;
            neg = true;
        }

        // Read in base-10 digits, up to the expected '.' char
        float ret = 0.0f;
        while ((b = s[i++]) != '.') {
            ret = (ret * 10.0f) + (float) (b - '0');
        }

        // Read the final digit which is after the '.'
        ret += ((s[i] - '0') / 10.0f);

        return neg ? -ret : ret;
    }
}

/**
 * Station names are converted into integers (see {@link Util#key(byte[], int)})
 * which fit into a known particular range; this "map" will simply index into
 * an array using these keys to find stations.
 */
@SuppressWarnings({ "unchecked" })
final class ArrayMap<V> extends AbstractMap<Integer, V> {
    final Object[] entries = new Object[1 << 16];

    @Override
    public V computeIfAbsent(Integer key, Function<? super Integer, ? extends V> mappingFunction) {
        var ret = entries[key];
        if (ret == null) {
            ret = entries[key] = mappingFunction.apply(key);
        }
        return (V) ret;
    }

    @Override
    public Collection<V> values() {
        var ret = new ArrayList<V>();
        for (var e : entries) {
            if (e != null) {
                ret.add((V) e);
            }
        }
        return ret;
    }

    @Override
    public Set<Entry<Integer, V>> entrySet() {
        throw new Error();
    }
}
